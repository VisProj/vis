<!doctype html>
<head>
  <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
  <meta content="utf-8" http-equiv="encoding">
</head>
<title>Brushing Example</title>
<link rel="stylesheet" type="text/css" href="style.css">
<script src="lib/d3.min.js"></script>
<script src="lib/d3.svg.multibrush.js"></script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>

<script src="d3.parcoords.js"></script>
<link rel="stylesheet" type="text/css" href="d3.parcoords.css">
<p id="demo"></p>

<div id="example" class="parcoords" style="width:100%;height:500px;min-width:1300px;"></div>

<p>Loads an external <a href="data/cars.csv">csv file</a>, creates a custom <a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-quantitative">quantitative color scale</a> using <a href="http://bl.ocks.org/3014589">L*a*b interpolation</a>, and enables brushing.

<p>
  <label for="sltBrushMode">Brush mode:</label>
  <select id="sltBrushMode">
  </select>
  <label id="lblPredicate" for="sltPredicate">Predicate:</label>
  <select id="sltPredicate">
    <option>AND</option>
    <option>OR</option>
  </select>
  <button id="btnReset">Reset Brushes</button>
</p>

<p id="pStrums" style="visibility: hidden;">Strumming is a 2D selection brushing method, also called pinches by Alfred Inselberg.
You start a strum be clicking and dragging within one of the segments (area between two axes).
After releasing the mouse button, the selection will contain all lines that pass through all of the active strums.

<script src="Connectors.js" type="text/javascript"></script>
<script src="Brushingscript.js" type="text/javascript"></script>


<script > 
/* not working
function dataParsing(data)
{	
	// the data is of type json . 
	
	document.getElementById("logs_p").innerHTML += "entered  dataParsing function<br>";
	var i,j;
	var data_length=data.length;
	var data_array =new Array(300);
	var element_exist_flag = 0;
	var temp_num;
	for(i=0;i<data_length;i++)
	{
		var single_quake = ParseArray(data[i]);
		//search if the place already exist in the  data_array
		// user the method map instead of this for 
		for(j=0;j<data_array.legth;j++)
		{
			element_exist_flag = 0;
			if(data_array[j] == single_quake[4])
			{
				temp_num= data_array[j][2];
				data_array[j][1] = temp_num+1;
				//update mag 
				data_array[j][2] = data_array[j][2] +single_quake[1];
				//update depth 
				data_array[j][3] = data_array[j][2 ] +single_quake[3];
				//update reliability 
				data_array[j][4] = data_array[j][2] + single_quake[5];
				element_exist_flag=1;
			}
		}
		if(element_exist_flag==0 )
		{//adda a new element to the array
			data_array.push( [single_quake[4],1,single_quake[1],single_quake[3],single_quake[5]]);			
		}
	}
	
	//divide the mag , depth , reliability  by number of wuake inn the place to get the average
	var temp_num = 1;
	for(i=0;i<data_array;i++)
	{
		temp_num= data[i][1];
		data_array[i][2] =data_array[i][2]/temp_num;
		data_array[i][3] =data_array[i][3]/temp_num;
		data_array[i][4] =data_array[i][4]/temp_num;
	}
	document.getElementById("logs_p").innerHTML += "exit  dataParsing function<br>";
	return data_array;
}

*/
</script>
